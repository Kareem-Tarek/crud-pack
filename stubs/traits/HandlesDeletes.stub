<?php

// ============================================================================
// FILE: stubs/traits/HandlesDeletes.stub
// UPDATED:
// - Trash (web) supports server-side search (q) + pagination appends
// - Trash (web) supports AJAX: returns only "crud_results" section HTML
// ============================================================================

namespace App\Traits;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Http\Request;
use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Gate;
use Illuminate\Support\Facades\Schema;

trait HandlesDeletes
{
    /**
     * True if the model uses SoftDeletes.
     * Controller may override, but this default works for both web/api controllers.
     */
    protected function supportsSoftDeletes(): bool
    {
        $uses = class_uses_recursive($this->modelClass) ?: [];
        return in_array(\Illuminate\Database\Eloquent\SoftDeletes::class, $uses, true);
    }

    /**
     * Generic, safe search:
     * - If table has "name" column => search by name LIKE
     * - Always allow exact ID match when numeric
     */
    protected function crudApplySearch($query, ?string $q)
    {
        $q = trim((string) $q);
        if ($q === '') return $query;

        $model = $query->getModel();
        $table = $model->getTable();

        $hasName = Schema::hasColumn($table, 'name');

        return $query->where(function ($w) use ($q, $hasName) {
            if (is_numeric($q)) {
                $w->orWhereKey((int) $q);
            }

            if ($hasName) {
                $w->orWhere('name', 'like', "%{$q}%");
            }
        });
    }

    /**
     * Dynamic authorization for both resource + custom methods.
     *
     * Controller sets:
     *   protected string $policyStyle = 'none|authorize|gate|resource';
     */
    protected function crudAuthorize(string $ability, mixed $arguments = null): void
    {
        $style = property_exists($this, 'policyStyle')
            ? strtolower(trim((string) $this->policyStyle))
            : 'none';

        if ($style === 'none') {
            return;
        }

        $args = $arguments ?? $this->modelClass;

        if ($style === 'authorize' || $style === 'resource') {
            if (method_exists($this, 'authorize')) {
                $this->authorize($ability, $args);
                return;
            }

            Gate::authorize($ability, $args);
            return;
        }

        if ($style === 'gate') {
            Gate::authorize($ability, $args);
            return;
        }
    }

    /* ============================================================
     | Controller-callable endpoints (NO "perform" prefix)
     ============================================================ */

    public function destroyBulk(Request $request)
    {
        $this->crudAuthorize('deleteBulk', $this->modelClass);
        return $this->performDestroyBulk($request);
    }

    public function trash()
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('trash', $this->modelClass);

        return $this->performTrash();
    }

    public function restore(int|string $id)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $model = $this->resolveTrashedModel($id);

        $this->crudAuthorize('restore', $model);

        return $this->performRestore($model);
    }

    public function restoreBulk(Request $request)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('restoreBulk', $this->modelClass);

        return $this->performRestoreBulk($request);
    }

    public function forceDelete(int|string $id)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $model = $this->resolveTrashedModel($id);

        $this->crudAuthorize('forceDelete', $model);

        return $this->performForceDelete($model);
    }

    public function forceDeleteBulk(Request $request)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('forceDeleteBulk', $this->modelClass);

        return $this->performForceDeleteBulk($request);
    }

    /* ============================================================
     | Core actions (WITH "perform" prefix)
     ============================================================ */

    public function performDestroy($modelOrId)
    {
        $model = $this->resolveModel($modelOrId);

        $model->delete();

        return $this->deleteResponse('Deleted successfully.');
    }

    public function performDestroyBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            return $this->deleteResponse('No records selected.');
        }

        $this->modelClass::query()->whereKey($ids)->delete();

        return $this->deleteResponse('Selected records deleted.');
    }

    /**
     * Trash listing logic (used by trash()).
     * - Supports server-side search (q)
     * - Supports AJAX: returns only "crud_results" HTML for web
     */
    public function performTrash()
    {
        $trashedTotal = $this->modelClass::onlyTrashed()->count();

        $q = request('q');

        $query = $this->modelClass::onlyTrashed();
        $query = $this->crudApplySearch($query, $q);

        $items = $query->paginate(15)->appends([
            'q' => $q,
        ]);

        $filteredTotal = $items->total();

        if (request()->expectsJson()) {
            return response()->json([
                'success'      => true,
                'message'      => 'OK',
                'trashedTotal' => $trashedTotal,
                'filteredTotal'=> $filteredTotal,
                'data'         => $items->items(),
                'meta'         => [
                    'current_page' => $items->currentPage(),
                    'per_page'     => $items->perPage(),
                    'last_page'    => $items->lastPage(),
                    'from'         => $items->firstItem(),
                    'to'           => $items->lastItem(),
                ],
            ], 200);
        }

        if (!property_exists($this, 'viewFolder') || empty($this->viewFolder)) {
            return redirect()->back()->with('error', 'View folder is not configured for this controller.');
        }

        $view = view($this->viewFolder . '.trash', compact('items', 'trashedTotal', 'filteredTotal'));

        // AJAX: return only the results HTML section
        if (request()->ajax()) {
            $sections = $view->renderSections();
            return response($sections['crud_results'] ?? $view->render(), 200);
        }

        return $view;
    }

    public function performRestore(Model $model)
    {
        $model->restore();

        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => 'Restored successfully.',
                'data'    => $model,
            ], 200);
        }

        return $this->deleteResponse('Restored successfully.');
    }

    public function performRestoreBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            if (request()->expectsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'No records selected.',
                ], 422);
            }

            return $this->deleteResponse('No records selected.');
        }

        $count = $this->modelClass::onlyTrashed()->whereKey($ids)->restore();

        if (request()->expectsJson()) {
            return response()->json([
                'success'       => true,
                'message'       => 'Selected records restored.',
                'restoredCount' => $count,
            ], 200);
        }

        return $this->deleteResponse('Selected records restored.');
    }

    public function performForceDelete(Model $model)
    {
        $model->forceDelete();

        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => 'Permanently deleted.',
            ], 200);
        }

        return $this->deleteResponse('Permanently deleted.');
    }

    public function performForceDeleteBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            if (request()->expectsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'No records selected.',
                ], 422);
            }

            return $this->deleteResponse('No records selected.');
        }

        $count = $this->modelClass::onlyTrashed()->whereKey($ids)->forceDelete();

        if (request()->expectsJson()) {
            return response()->json([
                'success'      => true,
                'message'      => 'Selected records permanently deleted.',
                'deletedCount' => $count,
            ], 200);
        }

        return $this->deleteResponse('Selected records permanently deleted.');
    }

    /* ===========================
     | Utilities
     =========================== */

    protected function softNotSupportedResponse()
    {
        if (request()->expectsJson()) {
            return response()->json([
                'success' => false,
                'message' => 'Soft deletes are not enabled for this resource.',
            ], 404);
        }

        return redirect()->back()->with('error', 'Soft deletes are not enabled for this resource.');
    }

    protected function extractIds(Request $request): array
    {
        $ids = $request->input('ids', []);

        if (is_string($ids)) {
            $ids = array_filter(array_map('trim', explode(',', $ids)));
        }

        return array_values(array_filter(Arr::wrap($ids)));
    }

    protected function resolveModel($modelOrId): Model
    {
        if ($modelOrId instanceof Model) {
            return $modelOrId;
        }

        return $this->modelClass::query()->findOrFail($modelOrId);
    }

    protected function resolveTrashedModel(int|string $id): Model
    {
        return $this->modelClass::onlyTrashed()->findOrFail($id);
    }

    protected function deleteResponse(string $message)
    {
        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => $message,
            ], 200);
        }

        return redirect()->back()->with('success', $message);
    }
}