<?php

// ============================================================================
// FILE: stubs/traits/HandlesDeletes.stub
// UPDATED:
// - Adds dynamic authorization helper: crudAuthorize() supporting none|authorize|gate|resource
// - Exposes controller-callable methods WITHOUT "perform" prefix:
//     destroyBulk, trash, restore, restoreBulk, forceDelete, forceDeleteBulk
// - Keeps core logic in "perform*" methods as requested
// - Soft-delete endpoints are guarded (safe response if SoftDeletes not supported)
// ============================================================================

namespace App\Http\Controllers\Concerns;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Http\Request;
use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Gate;

trait HandlesDeletes
{
    /**
     * True if the model uses SoftDeletes.
     * Controller may override, but this default works for both web/api controllers.
     */
    protected function supportsSoftDeletes(): bool
    {
        $uses = class_uses_recursive($this->modelClass) ?: [];
        return in_array(\Illuminate\Database\Eloquent\SoftDeletes::class, $uses, true);
    }

    /**
     * Dynamic authorization for both resource + custom methods.
     *
     * Controller sets:
     *   protected string $policyStyle = 'none|authorize|gate|resource';
     *
     * Notes:
     * - "resource" style auto-covers resource methods via authorizeResource(),
     *   BUT custom methods still need explicit authorization => we handle here.
     */
    protected function crudAuthorize(string $ability, mixed $arguments = null): void
    {
        $style = property_exists($this, 'policyStyle')
            ? strtolower(trim((string) $this->policyStyle))
            : 'none';

        if ($style === 'none') {
            return;
        }

        $args = $arguments ?? $this->modelClass;

        // "authorize" and "resource" both use authorize() when available
        if ($style === 'authorize' || $style === 'resource') {
            if (method_exists($this, 'authorize')) {
                $this->authorize($ability, $args);
                return;
            }

            Gate::authorize($ability, $args);
            return;
        }

        if ($style === 'gate') {
            Gate::authorize($ability, $args);
            return;
        }
    }

    /* ============================================================
     | Controller-callable endpoints (NO "perform" prefix)
     | - These are the methods your routes should point to.
     | - They authorize dynamically, then delegate to perform* methods.
     ============================================================ */

    /**
     * Bulk delete (exists ALWAYS: soft or no-soft).
     * Route points to: destroyBulk
     */
    public function destroyBulk(Request $request)
    {
        $this->crudAuthorize('deleteBulk', $this->modelClass);

        return $this->performDestroyBulk($request);
    }

    /**
     * List soft-deleted records (soft deletes only).
     * Route points to: trash
     */
    public function trash()
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('trash', $this->modelClass);

        return $this->performTrash();
    }

    /**
     * Restore single (soft deletes only).
     * Route points to: restore
     */
    public function restore(int|string $id)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $model = $this->resolveTrashedModel($id);

        $this->crudAuthorize('restore', $model);

        return $this->performRestore($model);
    }

    /**
     * Restore bulk (soft deletes only).
     * Route points to: restoreBulk
     */
    public function restoreBulk(Request $request)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('restoreBulk', $this->modelClass);

        return $this->performRestoreBulk($request);
    }

    /**
     * Force delete single (soft deletes only).
     * Route points to: forceDelete
     */
    public function forceDelete(int|string $id)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $model = $this->resolveTrashedModel($id);

        $this->crudAuthorize('forceDelete', $model);

        return $this->performForceDelete($model);
    }

    /**
     * Force delete bulk (soft deletes only).
     * Route points to: forceDeleteBulk
     */
    public function forceDeleteBulk(Request $request)
    {
        if (!$this->supportsSoftDeletes()) {
            return $this->softNotSupportedResponse();
        }

        $this->crudAuthorize('forceDeleteBulk', $this->modelClass);

        return $this->performForceDeleteBulk($request);
    }

    /* ============================================================
     | Core actions (WITH "perform" prefix)
     | - Controllers should call these for resource methods if needed.
     ============================================================ */

    /**
     * Single delete (resource destroy).
     * Works with Route::resource / Route::apiResource.
     *
     * IMPORTANT:
     * - Resource destroy receives {product} model binding if controller destroy(Product $product)
     * - If it receives id, we resolve via $this->modelClass.
     */
    public function performDestroy($modelOrId)
    {
        $model = $this->resolveModel($modelOrId);

        $model->delete();

        return $this->deleteResponse('Deleted successfully.');
    }

    /**
     * Bulk delete logic (used by destroyBulk()).
     * Works whether soft deletes are on or off.
     */
    public function performDestroyBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            return $this->deleteResponse('No records selected.');
        }

        $this->modelClass::query()->whereKey($ids)->delete();

        return $this->deleteResponse('Selected records deleted.');
    }

    /**
     * Trash listing logic (used by trash()).
     */
    public function performTrash()
    {
        $trashedTotal = $this->modelClass::onlyTrashed()->count();
        $items = $this->modelClass::onlyTrashed()->paginate(15);

        if (request()->expectsJson()) {
            return response()->json([
                'success'      => true,
                'message'      => 'OK',
                'trashedTotal' => $trashedTotal,
                'data'         => $items->items(),
                'meta'         => [
                    'current_page' => $items->currentPage(),
                    'per_page'     => $items->perPage(),
                    'last_page'    => $items->lastPage(),
                    'from'         => $items->firstItem(),
                    'to'           => $items->lastItem(),
                ],
            ], 200);
        }

        // Web only: require controller to define $viewFolder
        if (!property_exists($this, 'viewFolder') || empty($this->viewFolder)) {
            return redirect()->back()->with('error', 'View folder is not configured for this controller.');
        }

        return view($this->viewFolder . '.trash', compact('items', 'trashedTotal'));
    }

    /**
     * Restore single logic (used by restore()).
     */
    public function performRestore(Model $model)
    {
        $model->restore();

        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => 'Restored successfully.',
                'data'    => $model,
            ], 200);
        }

        return $this->deleteResponse('Restored successfully.');
    }

    /**
     * Restore bulk logic (used by restoreBulk()).
     */
    public function performRestoreBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            if (request()->expectsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'No records selected.',
                ], 422);
            }

            return $this->deleteResponse('No records selected.');
        }

        $count = $this->modelClass::onlyTrashed()->whereKey($ids)->restore();

        if (request()->expectsJson()) {
            return response()->json([
                'success'       => true,
                'message'       => 'Selected records restored.',
                'restoredCount' => $count,
            ], 200);
        }

        return $this->deleteResponse('Selected records restored.');
    }

    /**
     * Force delete single logic (used by forceDelete()).
     */
    public function performForceDelete(Model $model)
    {
        $model->forceDelete();

        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => 'Permanently deleted.',
            ], 200);
        }

        return $this->deleteResponse('Permanently deleted.');
    }

    /**
     * Force delete bulk logic (used by forceDeleteBulk()).
     */
    public function performForceDeleteBulk(Request $request)
    {
        $ids = $this->extractIds($request);

        if (empty($ids)) {
            if (request()->expectsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'No records selected.',
                ], 422);
            }

            return $this->deleteResponse('No records selected.');
        }

        $count = $this->modelClass::onlyTrashed()->whereKey($ids)->forceDelete();

        if (request()->expectsJson()) {
            return response()->json([
                'success'      => true,
                'message'      => 'Selected records permanently deleted.',
                'deletedCount' => $count,
            ], 200);
        }

        return $this->deleteResponse('Selected records permanently deleted.');
    }

    /* ===========================
     | Utilities
     =========================== */

    protected function softNotSupportedResponse()
    {
        if (request()->expectsJson()) {
            return response ()->json([
                'success' => false,
                'message' => 'Soft deletes are not enabled for this resource.',
            ], 404);
        }

        return redirect()->back()->with('error', 'Soft deletes are not enabled for this resource.');
    }

    protected function extractIds(Request $request): array
    {
        // Supports ids[] checkboxes OR comma-separated string "1,2,3"
        $ids = $request->input('ids', []);

        if (is_string($ids)) {
            $ids = array_filter(array_map('trim', explode(',', $ids)));
        }

        return array_values(array_filter(Arr::wrap($ids)));
    }

    protected function resolveModel($modelOrId): Model
    {
        if ($modelOrId instanceof Model) {
            return $modelOrId;
        }

        return $this->modelClass::query()->findOrFail($modelOrId);
    }

    protected function resolveTrashedModel(int|string $id): Model
    {
        return $this->modelClass::onlyTrashed()->findOrFail($id);
    }

    protected function deleteResponse(string $message)
    {
        if (request()->expectsJson()) {
            return response()->json([
                'success' => true,
                'message' => $message,
            ], 200);
        }

        return redirect()->back()->with('success', $message);
    }
}